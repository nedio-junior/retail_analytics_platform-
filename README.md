# üìä Projeto de An√°lise de E-commerce com PostgreSQL
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:52:55-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-Projeto%20de%20Estudo-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Projeto completo de estudo pr√°tico de PostgreSQL, abrangendo desde a cria√ß√£o do banco de dados at√© an√°lises avan√ßadas de dados de e-commerce.

## üìö √çndice
1. [Estrutura do Banco de Dados](#-estrutura-do-banco-de-dados)
2. [Dados de Teste](#-dados-de-teste)
3. [An√°lises Implementadas](#-an√°lises-implementadas)
4. [Como Executar](#-como-executar)
5. [Resultados e Insights](#-resultados-e-insights)

## üóÉÔ∏è Estrutura do Banco de Dados

### Diagrama ER
```mermaid
erDiagram
    FORNECEDORES ||--o{ PRODUTOS : fornece
    CATEGORIAS ||--o{ PRODUTOS : categoriza
    PRODUTOS ||--o{ ITENS_PEDIDO : contem
    CLIENTES ||--o{ PEDIDOS : realiza
    PEDIDOS ||--|{ ITENS_PEDIDO : possui
    PRODUTOS ||--o{ MOVIMENTACAO_ESTOQUE : movimenta
```

### Tabelas Principais
1. **Fornecedores**: Cadastro e avalia√ß√£o de fornecedores
2. **Categorias**: Classifica√ß√£o dos produtos
3. **Clientes**: Dados e m√©tricas dos clientes
4. **Produtos**: Cat√°logo completo de produtos
5. **Pedidos**: Registro de vendas
6. **Itens_Pedido**: Detalhamento dos pedidos
7. **Movimentacao_Estoque**: Controle de estoque

## üì• Dados de Teste

### Volume de Dados
- 5 Fornecedores
- 5 Categorias
- 5 Clientes
- 100 Produtos
- 50 Pedidos
- 150 Itens de Pedido
- 200 Movimenta√ß√µes de Estoque

### Distribui√ß√£o dos Dados
- **Status de Pedidos**: Distribui√ß√£o uniforme entre estados
- **Formas de Pagamento**: Distribui√ß√£o uniforme entre m√©todos
- **Margens de Lucro**: Varia√ß√£o por categoria (30% a 70%)

## üìä An√°lises Implementadas

### 1. Produtos Mais Vendidos
```sql
WITH vendas_produto AS (
    SELECT 
        p.id,
        p.nome,
        c.nome as categoria,
        COUNT(DISTINCT ip.pedido_id) as total_pedidos,
        SUM(ip.quantidade) as quantidade_vendida
        -- ... outros campos
)
```
**Objetivo**: Identificar best-sellers e padr√µes de venda

### 2. Margens de Lucro por Categoria
```sql
WITH margem_categoria AS (
    SELECT 
        c.nome as categoria,
        COUNT(DISTINCT p.id) as total_produtos,
        ROUND(AVG(p.margem_lucro)::numeric, 2) as margem_media
        -- ... outros campos
)
```
**Objetivo**: An√°lise de rentabilidade por segmento

### 3. Tempo M√©dio de Entrega
```sql
WITH metricas_entrega AS (
    SELECT 
        status,
        COUNT(*) as total_pedidos,
        ROUND(AVG(prazo_entrega)::numeric, 1) as prazo_medio_prometido
        -- ... outros campos
)
```
**Objetivo**: Monitoramento de performance log√≠stica

### 4. An√°lise RFM (Rec√™ncia, Frequ√™ncia, Monet√°rio)
```sql
WITH metricas_cliente AS (
    SELECT 
        c.id,
        c.nome,
        CURRENT_DATE - MAX(p.data_pedido)::date as recencia_dias
        -- ... outros campos
)
```
**Objetivo**: Segmenta√ß√£o avan√ßada de clientes

### 5. Previs√£o de Reposi√ß√£o de Estoque
```sql
WITH consumo_mensal AS (
    SELECT 
        produto_id,
        -SUM(CASE 
            WHEN tipo_movimento = 'sa√≠da' THEN quantidade
            ELSE 0
        END) as quantidade_vendida
        -- ... outros campos
)
```
**Objetivo**: Gest√£o proativa de estoque

## üöÄ Como Executar

### 1. Prepara√ß√£o do Ambiente
```bash
# Criar banco de dados
createdb ecommerce_db

# Conectar ao banco
psql -d ecommerce_db
```

### 2. Execu√ß√£o dos Scripts
```sql
-- 1. Criar estrutura
\i 01_create_tables.sql

-- 2. Inserir dados
\i 02_insert_data.sql

-- 3. Executar an√°lises
\i 03_analysis_queries.sql
```

## üìà Resultados e Insights

### 1. Performance de Produtos
- Identifica√ß√£o de produtos mais rent√°veis
- An√°lise de correla√ß√£o entre pre√ßo e volume de vendas
- Mapeamento de categorias em crescimento

### 2. Comportamento de Clientes
- Segmenta√ß√£o RFM
- Padr√µes de compra
- Lifetime Value

### 3. Efici√™ncia Operacional
- M√©tricas de entrega
- Gest√£o de estoque
- Performance de fornecedores

## ‚ö° Otimiza√ß√µes

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
CREATE INDEX idx_pedidos_data ON pedidos(data_pedido);
```

### 2. Views Materializadas
```sql
CREATE MATERIALIZED VIEW mv_vendas_diarias AS
-- Query de an√°lise de vendas
WITH (data-checks=true);
```

## üìä Visualiza√ß√µes Sugeridas

### 1. Dashboard de Vendas
```
Vendas por Categoria
‚îÇ
‚îú‚îÄ Eletr√¥nicos    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà R$ 1.000.000
‚îú‚îÄ Moda           ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     R$ 800.000
‚îî‚îÄ Acess√≥rios     ‚ñà‚ñà‚ñà‚ñà         R$ 400.000
```

### 2. Matriz RFM
```
R/F ‚îÇ 1   2   3   4   5
‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  5 ‚îÇ üî¥ üî¥ üü° üü¢ üü¢
  4 ‚îÇ üî¥ üü° üü° üü¢ üü¢
  3 ‚îÇ üî¥ üü° üü° üü° üü¢
```

## üîÑ Manuten√ß√£o

### 1. Rotinas Di√°rias
```sql
-- Atualizar views materializadas
REFRESH MATERIALIZED VIEW mv_vendas_diarias;

-- Vacuum an√°lises
VACUUM ANALYZE produtos, pedidos, itens_pedido;
```

### 2. Monitoramento
```sql
-- Verificar tamanho das tabelas
SELECT relname, pg_size_pretty(pg_total_relation_size(relid))
FROM pg_stat_user_tables;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:52:55 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Cria√ß√£o da estrutura do banco
- ‚úÖ Implementa√ß√£o das an√°lises
- ‚úÖ Documenta√ß√£o completa
- ‚úÖ Otimiza√ß√µes de performance

## üìö Refer√™ncias
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Modern SQL Guide](https://modern-sql.com/)
- [Database Design Guide](https://www.datablist.com/learn/postgresql)

# Passo a Passo detalhado de cada etapa e de cada an√°lise em ordem de constru√ß√£o do projeto

## üõçÔ∏è Schema de Banco de Dados E-commerce
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:43:08-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-Database%20Schema-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Esquema completo de banco de dados para sistema de e-commerce, incluindo gest√£o de produtos, pedidos, clientes, fornecedores e estoque.

## üìä Diagrama ER
```mermaid
erDiagram
    FORNECEDORES ||--o{ PRODUTOS : fornece
    CATEGORIAS ||--o{ PRODUTOS : categoriza
    PRODUTOS ||--o{ ITENS_PEDIDO : contem
    CLIENTES ||--o{ PEDIDOS : realiza
    PEDIDOS ||--|{ ITENS_PEDIDO : possui
    PRODUTOS ||--o{ MOVIMENTACAO_ESTOQUE : movimenta
```

## üóÉÔ∏è Estrutura das Tabelas

### 1. Fornecedores
```sql
CREATE TABLE fornecedores (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    cnpj VARCHAR(14) UNIQUE NOT NULL,
    prazo_medio_entrega INTEGER,
    avaliacao_qualidade DECIMAL(3,2),
    data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. Categorias
```sql
CREATE TABLE categorias (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) NOT NULL,
    descricao TEXT,
    margem_lucro_padrao DECIMAL(5,2),
    prazo_validade_medio INTEGER
);
```

### 3. Clientes
```sql
CREATE TABLE clientes (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    -- Outros campos
    nps INTEGER,
    data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 4. Produtos
```sql
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    sku VARCHAR(20) UNIQUE NOT NULL,
    nome VARCHAR(100) NOT NULL,
    -- Campos de relacionamento
    categoria_id INTEGER REFERENCES categorias(id),
    fornecedor_id INTEGER REFERENCES fornecedores(id),
    -- Campos de neg√≥cio
    preco_custo DECIMAL(10,2) NOT NULL,
    preco_venda DECIMAL(10,2) NOT NULL
);
```

### 5. Pedidos
```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    cliente_id INTEGER REFERENCES clientes(id),
    status VARCHAR(20) NOT NULL,
    -- Campos financeiros
    valor_produtos DECIMAL(10,2) NOT NULL,
    valor_frete DECIMAL(10,2) NOT NULL
);
```

## üîç √çndices Recomendados

### 1. √çndices de Busca
```sql
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_produtos_fornecedor ON produtos(fornecedor_id);
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
CREATE INDEX idx_pedidos_status ON pedidos(status);
```

### 2. √çndices de Performance
```sql
CREATE INDEX idx_produtos_sku ON produtos(sku);
CREATE INDEX idx_clientes_cpf ON clientes(cpf);
CREATE INDEX idx_movimentacao_data ON movimentacao_estoque(data_movimento);
```

## üìä Constraints e Valida√ß√µes

### 1. Checks de Neg√≥cio
```sql
ALTER TABLE produtos
ADD CONSTRAINT check_precos
CHECK (preco_venda >= preco_custo);

ALTER TABLE pedidos
ADD CONSTRAINT check_valores
CHECK (valor_total = valor_produtos + valor_frete - valor_desconto);
```

### 2. Valida√ß√µes de Dados
```sql
ALTER TABLE clientes
ADD CONSTRAINT check_cpf
CHECK (length(cpf) = 11);

ALTER TABLE produtos
ADD CONSTRAINT check_estoque
CHECK (estoque_minimo <= estoque_maximo);
```

## üîÑ Triggers Sugeridos

### 1. Atualiza√ß√£o de Estoque
```sql
CREATE TRIGGER atualiza_estoque
AFTER INSERT ON itens_pedido
FOR EACH ROW
EXECUTE FUNCTION atualiza_estoque_produto();
```

### 2. Hist√≥rico de Pre√ßos
```sql
CREATE TRIGGER log_alteracao_preco
BEFORE UPDATE OF preco_venda ON produtos
FOR EACH ROW
EXECUTE FUNCTION registra_historico_preco();
```

## üìà Views Recomendadas

### 1. Resumo de Vendas
```sql
CREATE VIEW vw_resumo_vendas AS
SELECT
    p.categoria_id,
    COUNT(DISTINCT p.id) as total_pedidos,
    SUM(ip.quantidade * ip.preco_unitario) as valor_total
FROM pedidos p
JOIN itens_pedido ip ON p.id = ip.pedido_id
GROUP BY p.categoria_id;
```

### 2. Status de Estoque
```sql
CREATE VIEW vw_status_estoque AS
SELECT
    p.id,
    p.nome,
    p.estoque_atual,
    CASE
        WHEN p.estoque_atual <= p.estoque_minimo THEN 'CR√çTICO'
        WHEN p.estoque_atual <= p.estoque_minimo * 1.5 THEN 'ATEN√á√ÉO'
        ELSE 'NORMAL'
    END as status_estoque
FROM produtos p;
```

## üîí Seguran√ßa

### 1. Roles e Permiss√µes
```sql
CREATE ROLE vendedor;
GRANT SELECT ON produtos TO vendedor;
GRANT INSERT ON pedidos TO vendedor;

CREATE ROLE estoquista;
GRANT SELECT, UPDATE ON produtos TO estoquista;
GRANT INSERT ON movimentacao_estoque TO estoquista;
```

### 2. Pol√≠ticas de Acesso
```sql
ALTER TABLE pedidos ENABLE ROW LEVEL SECURITY;
CREATE POLICY vendedor_policy ON pedidos
    FOR SELECT
    TO vendedor
    USING (vendedor_id = current_user_id());
```

## üìã Manuten√ß√£o

### 1. Vacuum e Analyze
```sql
-- Executar periodicamente
VACUUM ANALYZE produtos;
VACUUM ANALYZE pedidos;
VACUUM ANALYZE movimentacao_estoque;
```

### 2. Monitoramento de Tamanho
```sql
SELECT
    relname as tabela,
    pg_size_pretty(pg_total_relation_size(relid)) as tamanho
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:43:08 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Cria√ß√£o inicial do schema
- ‚úÖ Implementa√ß√£o de √≠ndices
- ‚úÖ Implementa√ß√£o de constraints
- ‚úÖ Documenta√ß√£o completa

---

## üìä Script de Dados de Teste - E-commerce 
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:45:27-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-Test%20Data%20Script-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Script desenvolvido para popular o banco de dados de e-commerce com dados de teste realistas, incluindo fornecedores, categorias, produtos, clientes, pedidos e movimenta√ß√µes de estoque.

## üìä Volume de Dados Gerados

| Entidade | Quantidade | Observa√ß√£o |
|----------|------------|------------|
| Fornecedores | 5 | Dados fixos |
| Categorias | 5 | Dados fixos |
| Clientes | 5 | Dados fixos |
| Produtos | 100 | Gerados dinamicamente |
| Pedidos | 50 | Gerados dinamicamente |
| Itens de Pedido | 150 | 1-5 itens por pedido |
| Movimenta√ß√µes | 200 | Entradas e sa√≠das |

## üîç Estrutura do Script

### 1. Fornecedores
```sql
INSERT INTO fornecedores (nome, cnpj, prazo_medio_entrega, avaliacao_qualidade) VALUES
('Tech Solutions Ltda', '12345678000100', 5, 4.5),
('Fashion Wear S.A.', '98765432000100', 7, 4.2),
...
```

### 2. Categorias
```sql
INSERT INTO categorias (nome, descricao, margem_lucro_padrao, prazo_validade_medio) VALUES
('Smartphones', 'Telefones celulares e acess√≥rios', 35.00, 730),
('Notebooks', 'Computadores port√°teis', 30.00, 730),
...
```

### 3. Gera√ß√£o de Produtos
```sql
DO $$
DECLARE
    i INTEGER;
    v_nome VARCHAR;
BEGIN
    FOR i IN 1..100 LOOP
        -- L√≥gica de gera√ß√£o
    END LOOP;
END $$;
```

## üìà Distribui√ß√£o dos Dados

### 1. Margens de Lucro por Categoria
- Smartphones: 35%
- Notebooks: 30%
- Vestu√°rio: 60%
- Eletr√¥nicos: 40%
- Acess√≥rios: 70%

### 2. Status de Pedidos
- PENDENTE: ~25%
- APROVADO: ~25%
- ENVIADO: ~25%
- ENTREGUE: ~25%

### 3. Formas de Pagamento
- CARTAO: ~33%
- BOLETO: ~33%
- PIX: ~33%

## ‚ö° Otimiza√ß√µes

### 1. Batch Inserts
```sql
-- Usar quando poss√≠vel
INSERT INTO tabela (campo1, campo2)
SELECT v1, v2
FROM unnest(array[...]) as t(v1, v2);
```

### 2. √çndices
```sql
-- Dropar √≠ndices antes da inser√ß√£o
DROP INDEX IF EXISTS idx_produtos_categoria;

-- Recriar ap√≥s inser√ß√£o
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
```

## üöÄ Como Usar

1. **Execu√ß√£o B√°sica**
```sql
\i script_insercao_dados.sql
```

2. **Execu√ß√£o com Timer**
```sql
\timing
\i script_insercao_dados.sql
```

3. **Execu√ß√£o com Log**
```sql
\o log_insercao.txt
\i script_insercao_dados.sql
\o
```

## üìä Valida√ß√µes Recomendadas

### 1. Contagem de Registros
```sql
SELECT
    (SELECT COUNT(*) FROM produtos) as total_produtos,
    (SELECT COUNT(*) FROM pedidos) as total_pedidos,
    (SELECT COUNT(*) FROM itens_pedido) as total_itens;
```

### 2. Verifica√ß√£o de Consist√™ncia
```sql
-- Verificar valores totais
SELECT
    p.id,
    p.valor_total,
    SUM(ip.quantidade * ip.preco_unitario) as soma_itens
FROM pedidos p
JOIN itens_pedido ip ON p.id = ip.pedido_id
GROUP BY p.id
HAVING p.valor_total != SUM(ip.quantidade * ip.preco_unitario);
```

## üîÑ Manuten√ß√£o

### 1. Limpeza dos Dados
```sql
-- Script para limpar todas as tabelas
TRUNCATE TABLE movimentacao_estoque CASCADE;
TRUNCATE TABLE itens_pedido CASCADE;
TRUNCATE TABLE pedidos CASCADE;
TRUNCATE TABLE produtos CASCADE;
TRUNCATE TABLE categorias CASCADE;
TRUNCATE TABLE fornecedores CASCADE;
TRUNCATE TABLE clientes CASCADE;
```

### 2. Reset de Sequences
```sql
-- Resetar todas as sequences
ALTER SEQUENCE produtos_id_seq RESTART WITH 1;
ALTER SEQUENCE pedidos_id_seq RESTART WITH 1;
```

## üìà An√°lises Sugeridas

1. **Distribui√ß√£o de Valores**
```sql
SELECT
    MIN(valor_total) as min_valor,
    MAX(valor_total) as max_valor,
    AVG(valor_total) as media_valor,
    percentile_cont(0.5) WITHIN GROUP (ORDER BY valor_total) as mediana
FROM pedidos;
```

2. **Distribui√ß√£o por Categoria**
```sql
SELECT
    c.nome,
    COUNT(p.id) as total_produtos,
    AVG(p.preco_venda) as preco_medio
FROM categorias c
JOIN produtos p ON c.id = p.categoria_id
GROUP BY c.nome;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:45:27 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial do script
- ‚úÖ Gera√ß√£o de dados de teste
- ‚úÖ Documenta√ß√£o completa

## üìä An√°lise de COHORT - E-commerce
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2003:46:15-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20de%20Cohort-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üìù Sobre a An√°lise
Query SQL desenvolvida para realizar an√°lise de cohort de clientes em e-commerce, permitindo visualizar padr√µes de reten√ß√£o e valor gerado por grupos de clientes ao longo do tempo.

## üéØ Objetivo
Analisar o comportamento de reten√ß√£o e valor gerado pelos clientes, agrupados pelo m√™s de sua primeira compra (cohort), permitindo entender:
- Taxa de reten√ß√£o ao longo do tempo
- Valor gerado por cada cohort mensalmente
- Padr√µes de comportamento de diferentes grupos de clientes

## üîç Estrutura da Query

### 1. Identifica√ß√£o da Primeira Compra
```sql
WITH primeira_compra AS (
    SELECT
        cliente_id,
        DATE_TRUNC('month', MIN(data_pedido)) as mes_primeira_compra
    FROM pedidos
    GROUP BY cliente_id
)
```
**Objetivo**: Identifica o m√™s da primeira compra de cada cliente.

### 2. An√°lise de Compras Mensais
```sql
compras_mensais AS (
    SELECT
        cliente_id,
        DATE_TRUNC('month', data_pedido) as mes_compra,
        COUNT(DISTINCT id) as num_compras,
        SUM(valor_total) as valor_total
    FROM pedidos
    GROUP BY cliente_id, DATE_TRUNC('month', data_pedido)
)
```
**Objetivo**: Agrega as compras por cliente e m√™s.

### 3. An√°lise Final do Cohort
```sql
cohort_analysis AS (
    SELECT
        pc.mes_primeira_compra,
        COUNT(DISTINCT pc.cliente_id) as clientes_originais,
        DATE_PART('month', cm.mes_compra - pc.mes_primeira_compra) as mes_desde_primeira_compra,
        COUNT(DISTINCT cm.cliente_id) as clientes_retidos,
        SUM(cm.valor_total) as receita_mes
    FROM primeira_compra pc
    LEFT JOIN compras_mensais cm ON pc.cliente_id = cm.cliente_id
    GROUP BY pc.mes_primeira_compra, DATE_PART('month', cm.mes_compra - pc.mes_primeira_compra)
    ORDER BY pc.mes_primeira_compra, mes_desde_primeira_compra
)
```

## üìä Colunas Retornadas

| Coluna | Tipo | Descri√ß√£o |
|--------|------|-----------|
| mes_primeira_compra | timestamp | M√™s em que o cohort come√ßou |
| clientes_originais | integer | N√∫mero total de clientes no cohort |
| mes_desde_primeira_compra | integer | N√∫mero de meses desde a primeira compra |
| clientes_retidos | integer | N√∫mero de clientes que compraram naquele m√™s |
| receita_mes | decimal | Receita total gerada no m√™s |

## üöÄ Como Usar

1. **Execu√ß√£o B√°sica**
```sql
SELECT * FROM cohort_analysis;
```

2. **Filtrar por Per√≠odo Espec√≠fico**
```sql
SELECT *
FROM cohort_analysis
WHERE mes_primeira_compra >= '2024-01-01'
AND mes_primeira_compra <= '2024-12-31';
```

3. **Calcular Taxa de Reten√ß√£o**
```sql
SELECT
    mes_primeira_compra,
    mes_desde_primeira_compra,
    ROUND((clientes_retidos::decimal / clientes_originais * 100), 2) as taxa_retencao
FROM cohort_analysis
WHERE mes_desde_primeira_compra > 0;
```

## üìà Visualiza√ß√£o Recomendada

```
M√™s desde    ‚îÇ Cohort 1  ‚îÇ Cohort 2  ‚îÇ Cohort 3
primeira     ‚îÇ (Jan)     ‚îÇ (Fev)     ‚îÇ (Mar)
compra       ‚îÇ          ‚îÇ          ‚îÇ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0            ‚îÇ 100%     ‚îÇ 100%     ‚îÇ 100%
1            ‚îÇ  45%     ‚îÇ  48%     ‚îÇ  50%
2            ‚îÇ  40%     ‚îÇ  42%     ‚îÇ  43%
3            ‚îÇ  38%     ‚îÇ  40%     ‚îÇ  41%
```

## üîç √çndices Recomendados
```sql
CREATE INDEX idx_pedidos_cliente_data ON pedidos(cliente_id, data_pedido);
CREATE INDEX idx_pedidos_valor ON pedidos(valor_total);
```

## ‚ö° Otimiza√ß√£o de Performance

1. **Particionamento Sugerido**
```sql
CREATE TABLE pedidos (
    ...
) PARTITION BY RANGE (data_pedido);
```

2. **View Materializada**
```sql
CREATE MATERIALIZED VIEW mv_cohort_analysis AS
-- Query cohort completa aqui
WITH (data-checks=true);
```

## üìã Pr√©-requisitos
- PostgreSQL 12+
- Tabela `pedidos` com campos:
  - `id`
  - `cliente_id`
  - `data_pedido`
  - `valor_total`

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o da An√°lise
```sql
REFRESH MATERIALIZED VIEW mv_cohort_analysis;
```

### Limpeza de Dados
```sql
-- Remover dados inconsistentes
DELETE FROM pedidos
WHERE data_pedido IS NULL
   OR valor_total <= 0;
```

## üìä Exemplos de Insights

1. **Taxa de Reten√ß√£o M√©dia**
```sql
SELECT
    mes_desde_primeira_compra,
    AVG(clientes_retidos::float / clientes_originais) as retencao_media
FROM cohort_analysis
GROUP BY mes_desde_primeira_compra
ORDER BY mes_desde_primeira_compra;
```

2. **Valor M√©dio por Cohort**
```sql
SELECT
    mes_primeira_compra,
    receita_mes / clientes_retidos as valor_medio_cliente
FROM cohort_analysis
WHERE clientes_retidos > 0;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 03:46:15 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de cohort
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## üìä An√°lise de Performance de Produtos e Categorias
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2003:51:59-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20de%20Performance-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query SQL desenvolvida para an√°lise profunda de performance de produtos e categorias em e-commerce, fornecendo insights sobre receita, lucratividade, avalia√ß√µes e rankings de produtos.

## üîç Estrutura da Query

### 1. M√©tricas por Produto
```sql
WITH metricas_produto AS (
    SELECT
        p.id,
        p.nome,
        c.nome as categoria,
        p.preco_venda,
        p.preco_custo,
        p.quantidade_vendida_total,
        p.media_avaliacao,
        SUM(ip.quantidade) as unidades_vendidas,
        SUM(ip.quantidade * ip.preco_unitario) as receita_total,
        SUM(ip.quantidade * (ip.preco_unitario - p.preco_custo)) as lucro_total
    FROM produtos p
    LEFT JOIN categorias c ON p.categoria_id = c.id
    LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
    GROUP BY p.id, p.nome, c.nome, p.preco_venda, p.preco_custo,
             p.quantidade_vendida_total, p.media_avaliacao
)
```

### 2. Ranking de Produtos
```sql
rank_produtos AS (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY categoria
                          ORDER BY receita_total DESC) as rank_categoria,
        ROW_NUMBER() OVER (ORDER BY receita_total DESC) as rank_geral
    FROM metricas_produto
)
```

## üìä M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| receita_total | Receita total por produto | `quantidade * preco_unitario` |
| lucro_total | Lucro total por produto | `quantidade * (preco_unitario - preco_custo)` |
| rank_categoria | Posi√ß√£o do produto na categoria | `ROW_NUMBER()` por categoria |
| rank_geral | Posi√ß√£o geral do produto | `ROW_NUMBER()` geral |

## üìà Resultados Retornados

| Coluna | Tipo | Descri√ß√£o |
|--------|------|-----------|
| categoria | text | Nome da categoria |
| total_produtos | integer | N√∫mero de produtos na categoria |
| receita_categoria | numeric | Receita total da categoria |
| lucro_categoria | numeric | Lucro total da categoria |
| avaliacao_media | numeric | M√©dia das avalia√ß√µes dos produtos |
| top_3_produtos | text | Top 3 produtos da categoria com receita |

## üöÄ Como Usar

1. **Execu√ß√£o B√°sica**
```sql
SELECT * FROM rank_produtos;
```

2. **An√°lise por Categoria Espec√≠fica**
```sql
SELECT *
FROM rank_produtos
WHERE categoria = 'Nome da Categoria';
```

3. **Top 10 Produtos Gerais**
```sql
SELECT nome, receita_total, rank_geral
FROM rank_produtos
WHERE rank_geral <= 10
ORDER BY rank_geral;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Gr√°fico de Barras - Top Categorias
```
Receita por Categoria
‚îÇ
‚îú‚îÄ Eletr√¥nicos    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà R$ 1.000.000
‚îú‚îÄ Moda           ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     R$ 800.000
‚îú‚îÄ Casa           ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       R$ 600.000
‚îî‚îÄ Acess√≥rios     ‚ñà‚ñà‚ñà‚ñà         R$ 400.000
```

### 2. Tabela de Performance
```
Categoria    ‚îÇ Produtos ‚îÇ Receita  ‚îÇ Lucro    ‚îÇ Avalia√ß√£o
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Eletr√¥nicos  ‚îÇ    50    ‚îÇ 1.000k   ‚îÇ 300k     ‚îÇ 4.5
Moda         ‚îÇ    75    ‚îÇ 800k     ‚îÇ 240k     ‚îÇ 4.3
Casa         ‚îÇ    30    ‚îÇ 600k     ‚îÇ 180k     ‚îÇ 4.7
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_itens_pedido_produto ON itens_pedido(produto_id);
CREATE INDEX idx_produtos_receita ON produtos(receita_total DESC);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_performance_produtos AS
-- Query completa aqui
WITH (data-checks=true);
```

## üìã Pr√©-requisitos

### Estrutura de Tabelas
```sql
CREATE TABLE produtos (
    id serial PRIMARY KEY,
    nome text,
    categoria_id integer,
    preco_venda numeric,
    preco_custo numeric,
    media_avaliacao numeric
);

CREATE TABLE categorias (
    id serial PRIMARY KEY,
    nome text
);

CREATE TABLE itens_pedido (
    produto_id integer,
    quantidade integer,
    preco_unitario numeric
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o dos Dados
```sql
REFRESH MATERIALIZED VIEW mv_performance_produtos;
```

### Limpeza de Dados
```sql
-- Remover produtos sem categoria
UPDATE produtos
SET categoria_id = 1
WHERE categoria_id IS NULL;
```

## üìä Exemplos de Insights

1. **Margem de Lucro por Categoria**
```sql
SELECT
    categoria,
    (lucro_categoria / receita_categoria * 100)::numeric(5,2) as margem_percentual
FROM rank_produtos
GROUP BY categoria;
```

2. **Correla√ß√£o Pre√ßo vs Avalia√ß√£o**
```sql
SELECT
    categoria,
    CORR(preco_venda, media_avaliacao) as correlacao
FROM rank_produtos
GROUP BY categoria;
```

## üîç M√©tricas de Monitoramento
- Tempo de execu√ß√£o da query
- Uso de √≠ndices
- Taxa de atualiza√ß√£o dos dados
- Precis√£o das m√©tricas

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 03:51:59 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de performance
- ‚úÖ Otimiza√ß√£o de queries
- ‚úÖ Documenta√ß√£o completa

---
## üîç An√°lise de Funil de Vendas e Convers√£o
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2003:54:41-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-Funil%20de%20Vendas-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query SQL desenvolvida para an√°lise detalhada do funil de vendas em e-commerce, permitindo visualizar taxas de convers√£o entre etapas e identificar poss√≠veis gargalos no processo de venda.

## üìä Estrutura do Funil

```mermaid
graph TD
    A[PENDENTE] --> B[APROVADO]
    B --> C[ENVIADO]
    C --> D[ENTREGUE]
```

## üîç Estrutura da Query

### 1. An√°lise do Status do Funil
```sql
WITH funil_status AS (
    SELECT
        status,
        COUNT(*) as total_pedidos,
        SUM(valor_total) as valor_total,
        LAG(COUNT(*)) OVER (
            ORDER BY
            CASE status
                WHEN 'PENDENTE' THEN 1
                WHEN 'APROVADO' THEN 2
                WHEN 'ENVIADO' THEN 3
                WHEN 'ENTREGUE' THEN 4
            END
        ) as status_anterior
    FROM pedidos
    GROUP BY status
)
```

### 2. C√°lculo de Convers√µes
```sql
SELECT
    status,
    total_pedidos,
    valor_total,
    ROUND((total_pedidos::numeric / FIRST_VALUE(total_pedidos) OVER (...) * 100), 2) as taxa_conversao_total,
    ROUND((total_pedidos::numeric / NULLIF(status_anterior, 0) * 100), 2) as taxa_conversao_etapa
```

## üìà M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| total_pedidos | Total de pedidos em cada status | `COUNT(*)` |
| valor_total | Valor total dos pedidos | `SUM(valor_total)` |
| taxa_conversao_total | % em rela√ß√£o ao in√≠cio do funil | `(total_pedidos / primeiro_status * 100)` |
| taxa_conversao_etapa | % em rela√ß√£o √† etapa anterior | `(total_pedidos / status_anterior * 100)` |

## üéØ Exemplo de Resultado

```
Status    ‚îÇ Total ‚îÇ Valor Total ‚îÇ Conv. Total ‚îÇ Conv. Etapa
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
PENDENTE  ‚îÇ  1000 ‚îÇ   100000.00 ‚îÇ    100.00%  ‚îÇ     -
APROVADO  ‚îÇ   800 ‚îÇ    80000.00 ‚îÇ     80.00%  ‚îÇ    80.00%
ENVIADO   ‚îÇ   750 ‚îÇ    75000.00 ‚îÇ     75.00%  ‚îÇ    93.75%
ENTREGUE  ‚îÇ   700 ‚îÇ    70000.00 ‚îÇ     70.00%  ‚îÇ    93.33%
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_pedidos_status ON pedidos(status);
CREATE INDEX idx_pedidos_valor ON pedidos(valor_total);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_funil_vendas AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise B√°sica do Funil**
```sql
SELECT * FROM mv_funil_vendas;
```

2. **An√°lise por Per√≠odo**
```sql
WITH funil_status AS (
    SELECT
        status,
        COUNT(*) as total_pedidos
    FROM pedidos
    WHERE data_pedido >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY status
)
SELECT * FROM funil_status;
```

3. **Compara√ß√£o de Per√≠odos**
```sql
SELECT
    status,
    COUNT(*) FILTER (WHERE data_pedido >= CURRENT_DATE - INTERVAL '30 days') as mes_atual,
    COUNT(*) FILTER (WHERE data_pedido >= CURRENT_DATE - INTERVAL '60 days'
                     AND data_pedido < CURRENT_DATE - INTERVAL '30 days') as mes_anterior
FROM pedidos
GROUP BY status;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Funil de Convers√£o
```
PENDENTE  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 1000
APROVADO  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    800
ENVIADO   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     750
ENTREGUE  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà      700
```

### 2. Gr√°fico de Barras - Valor por Status
```
PENDENTE  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà R$ 100k
APROVADO  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    R$ 80k
ENVIADO   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     R$ 75k
ENTREGUE  ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà      R$ 70k
```

## üìã Pr√©-requisitos

### Estrutura da Tabela
```sql
CREATE TABLE pedidos (
    id serial PRIMARY KEY,
    status text,
    valor_total numeric,
    data_pedido timestamp
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o dos Dados
```sql
REFRESH MATERIALIZED VIEW mv_funil_vendas;
```

### Monitoramento
```sql
-- Verificar inconsist√™ncias
SELECT status, COUNT(*)
FROM pedidos
WHERE status NOT IN ('PENDENTE', 'APROVADO', 'ENVIADO', 'ENTREGUE')
GROUP BY status;
```

## üìä KPIs Sugeridos

1. **Taxa de Abandono por Etapa**
```sql
SELECT
    status,
    100 - taxa_conversao_etapa as taxa_abandono
FROM mv_funil_vendas;
```

2. **Valor M√©dio por Status**
```sql
SELECT
    status,
    valor_total / total_pedidos as ticket_medio
FROM mv_funil_vendas;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 03:54:41 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de funil
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## üìä An√°lise RFM (Rec√™ncia, Frequ√™ncia, Monet√°rio)
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2003:57:14-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20RFM-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
An√°lise RFM desenvolvida para segmenta√ß√£o avan√ßada de clientes, considerando padr√µes de compra baseados em Rec√™ncia (R), Frequ√™ncia (F) e valor Monet√°rio (M).

## üìà Componentes RFM

```mermaid
graph LR
    A[Rec√™ncia] --> D[Score RFM]
    B[Frequ√™ncia] --> D
    C[Monet√°rio] --> D
    D --> E[Segmenta√ß√£o]
```

## üîç Estrutura da Query

### 1. M√©tricas por Cliente
```sql
WITH metricas_cliente AS (
    SELECT
        c.id,
        c.nome,
        c.classificacao,
        CURRENT_DATE - MAX(p.data_pedido)::date as recencia_dias,
        COUNT(DISTINCT p.id) as frequencia_pedidos,
        SUM(p.valor_total) as valor_total_compras,
        AVG(p.valor_total) as ticket_medio
    FROM clientes c
    LEFT JOIN pedidos p ON c.id = p.cliente_id
    GROUP BY c.id, c.nome, c.classificacao
)
```

### 2. C√°lculo de Scores RFM
```sql
scores_rfm AS (
    SELECT
        *,
        NTILE(5) OVER (ORDER BY recencia_dias DESC) as R,
        NTILE(5) OVER (ORDER BY frequencia_pedidos) as F,
        NTILE(5) OVER (ORDER BY valor_total_compras) as M
    FROM metricas_cliente
)
```

## üìä Segmentos RFM

| Segmento | Score RFM | Descri√ß√£o |
|----------|-----------|-----------|
| CHAMPIONS | ‚â• 13 | Clientes de alto valor e engajamento |
| LOYAL CUSTOMERS | ‚â• 10 | Clientes fi√©is e consistentes |
| POTENTIAL LOYALISTS | ‚â• 7 | Clientes com potencial de fideliza√ß√£o |
| AT RISK | ‚â• 5 | Clientes em risco de abandono |
| LOST | < 5 | Clientes inativos ou perdidos |

## üìà M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| recencia_dias | Dias desde √∫ltima compra | `CURRENT_DATE - MAX(data_pedido)` |
| frequencia_pedidos | Total de pedidos | `COUNT(DISTINCT pedidos.id)` |
| valor_total_compras | Valor total gasto | `SUM(valor_total)` |
| ticket_medio | Valor m√©dio por pedido | `AVG(valor_total)` |

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_pedidos_cliente_data ON pedidos(cliente_id, data_pedido);
CREATE INDEX idx_pedidos_valor ON pedidos(valor_total);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_rfm_analysis AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise B√°sica RFM**
```sql
SELECT * FROM mv_rfm_analysis ORDER BY score_rfm DESC;
```

2. **An√°lise por Segmento**
```sql
SELECT
    segmento_rfm,
    COUNT(*) as total_clientes,
    ROUND(AVG(valor_total), 2) as valor_medio
FROM mv_rfm_analysis
GROUP BY segmento_rfm
ORDER BY valor_medio DESC;
```

3. **Identifica√ß√£o de Clientes em Risco**
```sql
SELECT *
FROM mv_rfm_analysis
WHERE segmento_rfm = 'AT RISK'
ORDER BY valor_total DESC;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Distribui√ß√£o de Segmentos
```
CHAMPIONS         ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 20%
LOYAL CUSTOMERS   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   15%
POTENTIAL         ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 20%
AT RISK          ‚îÇ‚ñà‚ñà‚ñà‚ñà     10%
LOST             ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 35%
```

### 2. Matriz RFM
```
R/F ‚îÇ 1   2   3   4   5
‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  5 ‚îÇ üî¥ üî¥ üü° üü¢ üü¢
  4 ‚îÇ üî¥ üü° üü° üü¢ üü¢
  3 ‚îÇ üî¥ üü° üü° üü° üü¢
  2 ‚îÇ üî¥ üî¥ üü° üü° üü°
  1 ‚îÇ üî¥ üî¥ üî¥ üü° üü°
```

## üìã Pr√©-requisitos

### Estrutura das Tabelas
```sql
CREATE TABLE clientes (
    id serial PRIMARY KEY,
    nome text,
    classificacao text
);

CREATE TABLE pedidos (
    id serial PRIMARY KEY,
    cliente_id integer,
    data_pedido date,
    valor_total numeric
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o Di√°ria
```sql
REFRESH MATERIALIZED VIEW mv_rfm_analysis;
```

### Monitoramento
```sql
-- Verificar distribui√ß√£o dos segmentos
SELECT
    segmento_rfm,
    COUNT(*),
    ROUND(COUNT(*)::numeric / SUM(COUNT(*)) OVER () * 100, 2) as percentual
FROM mv_rfm_analysis
GROUP BY segmento_rfm;
```

## üìä Insights Sugeridos

1. **Valor por Segmento**
```sql
SELECT
    segmento_rfm,
    SUM(valor_total) as valor_total,
    COUNT(*) as total_clientes,
    SUM(valor_total) / COUNT(*) as valor_por_cliente
FROM mv_rfm_analysis
GROUP BY segmento_rfm;
```

2. **Rec√™ncia M√©dia por Segmento**
```sql
SELECT
    segmento_rfm,
    ROUND(AVG(recencia_dias)) as recencia_media
FROM mv_rfm_analysis
GROUP BY segmento_rfm;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 03:57:14 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise RFM
- ‚úÖ Segmenta√ß√£o de clientes
- ‚úÖ Documenta√ß√£o completa

---
## üìä Top 20 Produtos Mais Vendidos
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:26:03-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20de%20Vendas-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query desenvolvida para identificar e analisar os 20 produtos mais vendidos, considerando quantidade, receita, avalia√ß√µes e participa√ß√£o nas vendas totais.

## üîç Estrutura da Query

### 1. An√°lise de Vendas por Produto
```sql
WITH vendas_produto AS (
    SELECT
        p.id,
        p.nome,
        c.nome as categoria,
        COUNT(DISTINCT ip.pedido_id) as total_pedidos,
        SUM(ip.quantidade) as quantidade_vendida,
        SUM(ip.quantidade * ip.preco_unitario) as receita_total,
        ROUND(AVG(ip.avaliacao_produto)::numeric, 2) as media_avaliacao
    FROM produtos p
    LEFT JOIN categorias c ON p.categoria_id = c.id
    LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
    GROUP BY p.id, p.nome, c.nome
)
```

## üìä M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| total_pedidos | N√∫mero de pedidos distintos | `COUNT(DISTINCT pedido_id)` |
| quantidade_vendida | Total de unidades vendidas | `SUM(quantidade)` |
| receita_total | Receita total gerada | `SUM(quantidade * preco_unitario)` |
| media_avaliacao | M√©dia das avalia√ß√µes | `AVG(avaliacao_produto)` |
| percentual_vendas | % do total de vendas | `(quantidade_vendida / total_geral) * 100` |

## üìà Exemplo de Resultado

```
Produto    ‚îÇ Categoria ‚îÇ Qtd ‚îÇ Receita  ‚îÇ Avalia√ß√£o ‚îÇ % Vendas
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Produto A  ‚îÇ Tech     ‚îÇ 500 ‚îÇ 50000.00 ‚îÇ     4.8   ‚îÇ   15.5%
Produto B  ‚îÇ Casa     ‚îÇ 450 ‚îÇ 45000.00 ‚îÇ     4.5   ‚îÇ   14.0%
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_itens_pedido_produto ON itens_pedido(produto_id);
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_vendas_quantidade ON vendas_produto(quantidade_vendida DESC);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_top_produtos AS
-- Query completa aqui
WITH (data-checks=true);

-- Atualiza√ß√£o
REFRESH MATERIALIZED VIEW mv_top_produtos;
```

## üöÄ Como Usar

1. **An√°lise B√°sica**
```sql
SELECT * FROM mv_top_produtos LIMIT 20;
```

2. **An√°lise por Categoria**
```sql
SELECT
    categoria,
    COUNT(*) as total_produtos,
    SUM(quantidade_vendida) as total_vendido,
    ROUND(AVG(media_avaliacao), 2) as avaliacao_media
FROM mv_top_produtos
GROUP BY categoria;
```

3. **Produtos com Alta Avalia√ß√£o**
```sql
SELECT *
FROM mv_top_produtos
WHERE media_avaliacao >= 4.5
ORDER BY quantidade_vendida DESC;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Gr√°fico de Pareto
```
Produto ‚îÇ Quantidade ‚îÇ % Acumulado
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Prod A  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚îÇ     15.5%
Prod B  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚îÇ     29.5%
Prod C  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚îÇ     41.0%
```

### 2. Matriz Quantidade x Avalia√ß√£o
```
Avalia√ß√£o
   5 ‚îÇ   ‚àô  ‚àô‚àô  ‚àô
   4 ‚îÇ ‚àô  ‚àô‚àô‚àô ‚àô‚àô ‚àô
   3 ‚îÇ   ‚àô‚àô ‚àô  ‚àô
   2 ‚îÇ ‚àô  ‚àô
   1 ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       100  500  1000  Quantidade
```

## üìã Pr√©-requisitos

### Estrutura das Tabelas
```sql
CREATE TABLE produtos (
    id serial PRIMARY KEY,
    nome text,
    categoria_id integer
);

CREATE TABLE categorias (
    id serial PRIMARY KEY,
    nome text
);

CREATE TABLE itens_pedido (
    produto_id integer,
    pedido_id integer,
    quantidade integer,
    preco_unitario numeric,
    avaliacao_produto numeric
);
```

## üîÑ Manuten√ß√£o

### Monitoramento de Performance
```sql
EXPLAIN ANALYZE SELECT * FROM mv_top_produtos;
```

### Valida√ß√£o de Dados
```sql
-- Verificar produtos sem vendas
SELECT p.nome
FROM produtos p
LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
WHERE ip.produto_id IS NULL;
```

## üìä KPIs Sugeridos

1. **Concentra√ß√£o de Vendas**
```sql
WITH vendas_acumuladas AS (
    SELECT
        *,
        SUM(percentual_vendas) OVER (ORDER BY quantidade_vendida DESC) as perc_acumulado
    FROM mv_top_produtos
)
SELECT * FROM vendas_acumuladas WHERE perc_acumulado <= 80;
```

2. **Performance por Categoria**
```sql
SELECT
    categoria,
    COUNT(*) as produtos_top20,
    SUM(quantidade_vendida) as total_vendido,
    AVG(media_avaliacao) as media_avaliacoes
FROM mv_top_produtos
GROUP BY categoria;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:26:03 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de produtos
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## üìà An√°lise de Margens de Lucro por Categoria
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:32:59-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20Financeira-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query desenvolvida para an√°lise detalhada das margens de lucro por categoria de produtos, comparando margens esperadas com resultados reais e identificando oportunidades de otimiza√ß√£o.

## üí∞ M√©tricas Principais
```mermaid
graph LR
    A[Receita Total] --> D[Margem Real]
    B[Custo Total] --> D
    C[Margem Esperada] --> E[Comparativo]
    D --> E
```

## üîç Estrutura da Query

### 1. An√°lise de Margem por Categoria
```sql
WITH margem_categoria AS (
    SELECT
        c.nome as categoria,
        COUNT(DISTINCT p.id) as total_produtos,
        ROUND(AVG(p.margem_lucro)::numeric, 2) as margem_media,
        SUM(ip.quantidade * ip.preco_unitario) as receita_total,
        SUM(ip.quantidade * p.preco_custo) as custo_total
    FROM categorias c
    LEFT JOIN produtos p ON c.id = p.categoria_id
    LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
    GROUP BY c.nome
)
```

## üìä M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| margem_media_percentual | Margem esperada | `AVG(margem_lucro)` |
| receita_total | Receita bruta | `SUM(quantidade * preco_unitario)` |
| custo_total | Custo total | `SUM(quantidade * preco_custo)` |
| lucro_total | Lucro realizado | `receita_total - custo_total` |
| margem_real_percentual | Margem real | `(lucro_total / receita_total) * 100` |

## üìà Exemplo de Resultado

```
Categoria  ‚îÇ Produtos ‚îÇ Margem % ‚îÇ Receita  ‚îÇ Custo    ‚îÇ Lucro    ‚îÇ Margem Real %
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Eletr√¥nicos‚îÇ    50    ‚îÇ   35.00  ‚îÇ 100000.00‚îÇ  70000.00‚îÇ  30000.00‚îÇ    30.00
Casa       ‚îÇ    75    ‚îÇ   40.00  ‚îÇ  80000.00‚îÇ  50000.00‚îÇ  30000.00‚îÇ    37.50
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_produtos_margem ON produtos(margem_lucro);
CREATE INDEX idx_itens_produto ON itens_pedido(produto_id);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_margem_categoria AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise B√°sica de Margens**
```sql
SELECT * FROM mv_margem_categoria ORDER BY lucro_total DESC;
```

2. **Categorias com Margem Abaixo do Esperado**
```sql
SELECT *
FROM mv_margem_categoria
WHERE margem_real_percentual < margem_media_percentual
ORDER BY (margem_media_percentual - margem_real_percentual) DESC;
```

3. **Top 5 Categorias Mais Lucrativas**
```sql
SELECT *
FROM mv_margem_categoria
ORDER BY lucro_total DESC
LIMIT 5;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Comparativo de Margens
```
Categoria    ‚îÇ Margem Esperada ‚îÇ Margem Real
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Eletr√¥nicos  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 40%   ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 30%
Casa         ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  35%   ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 35%
Moda         ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   30%   ‚îÇ ‚ñà‚ñà‚ñà‚ñà 20%
```

### 2. Matriz de Rentabilidade
```
Margem %
   50 ‚îÇ   ‚àô  ‚àô
   40 ‚îÇ ‚àô  ‚àô‚àô ‚àô
   30 ‚îÇ   ‚àô‚àô ‚àô  ‚àô
   20 ‚îÇ ‚àô  ‚àô
   10 ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      20k  50k  100k  Receita
```

## üìã Pr√©-requisitos

### Estrutura das Tabelas
```sql
CREATE TABLE categorias (
    id serial PRIMARY KEY,
    nome text
);

CREATE TABLE produtos (
    id serial PRIMARY KEY,
    categoria_id integer,
    margem_lucro numeric,
    preco_custo numeric
);

CREATE TABLE itens_pedido (
    produto_id integer,
    quantidade integer,
    preco_unitario numeric
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o Di√°ria
```sql
REFRESH MATERIALIZED VIEW mv_margem_categoria;
```

### Monitoramento
```sql
-- Verificar categorias sem vendas
SELECT c.nome
FROM categorias c
LEFT JOIN produtos p ON c.id = p.categoria_id
LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
WHERE ip.produto_id IS NULL;
```

## üìä KPIs Sugeridos

1. **Diferen√ßa entre Margem Esperada e Real**
```sql
SELECT
    categoria,
    margem_media_percentual - margem_real_percentual as diferenca_margem
FROM mv_margem_categoria
ORDER BY diferenca_margem DESC;
```

2. **Rentabilidade por Produto**
```sql
SELECT
    categoria,
    lucro_total / total_produtos as lucro_por_produto
FROM mv_margem_categoria
ORDER BY lucro_por_produto DESC;
```

## üìà An√°lises Complementares

1. **Tend√™ncia de Margem**
```sql
SELECT
    DATE_TRUNC('month', ip.data_venda) as mes,
    c.nome as categoria,
    ROUND(((SUM(ip.quantidade * ip.preco_unitario) -
            SUM(ip.quantidade * p.preco_custo)) /
           SUM(ip.quantidade * ip.preco_unitario) * 100)::numeric, 2) as margem
FROM categorias c
JOIN produtos p ON c.id = p.categoria_id
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY mes, c.nome
ORDER BY mes, c.nome;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:32:59 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de margens
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## üöö An√°lise de Tempo M√©dio de Entrega
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:35:23-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20Log√≠stica-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query desenvolvida para an√°lise detalhada dos tempos de entrega, comparando prazos prometidos com tempos reais e avaliando a satisfa√ß√£o dos clientes com o servi√ßo de entrega.

## üìä Fluxo de Entrega
```mermaid
graph LR
    A[PENDENTE] --> B[APROVADO]
    B --> C[ENVIADO]
    C --> D[ENTREGUE]
    D --> E{Avalia√ß√£o}
    E --> F[Satisfa√ß√£o]
```

## üîç Estrutura da Query

### 1. M√©tricas de Entrega
```sql
WITH metricas_entrega AS (
    SELECT
        status,
        COUNT(*) as total_pedidos,
        ROUND(AVG(prazo_entrega)::numeric, 1) as prazo_medio_prometido,
        ROUND(AVG(
            CASE
                WHEN data_entrega_real IS NOT NULL
                THEN DATE_PART('day', data_entrega_real - data_pedido)
            END
        )::numeric, 1) as tempo_medio_real,
        ROUND(AVG(avaliacao_entrega)::numeric, 2) as satisfacao_media
    FROM pedidos
    GROUP BY status
)
```

## üìà M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| prazo_medio_prometido | Prazo prometido em dias | `AVG(prazo_entrega)` |
| tempo_medio_real | Tempo real de entrega | `AVG(data_entrega_real - data_pedido)` |
| satisfacao_media | M√©dia das avalia√ß√µes | `AVG(avaliacao_entrega)` |
| status_entrega | Status do prazo | `tempo_real vs prazo_prometido` |

## üìä Exemplo de Resultado

```
Status    ‚îÇ Pedidos ‚îÇ Prazo ‚îÇ Real ‚îÇ Status    ‚îÇ Satisfa√ß√£o
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
PENDENTE  ‚îÇ   100   ‚îÇ   5   ‚îÇ  -   ‚îÇ    -      ‚îÇ    -
APROVADO  ‚îÇ   80    ‚îÇ   5   ‚îÇ  -   ‚îÇ    -      ‚îÇ    -
ENVIADO   ‚îÇ   70    ‚îÇ   5   ‚îÇ  4   ‚îÇ No Prazo  ‚îÇ   4.5
ENTREGUE  ‚îÇ   60    ‚îÇ   5   ‚îÇ  6   ‚îÇ Atrasado  ‚îÇ   3.8
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_pedidos_status ON pedidos(status);
CREATE INDEX idx_pedidos_datas ON pedidos(data_pedido, data_entrega_real);
CREATE INDEX idx_pedidos_avaliacao ON pedidos(avaliacao_entrega);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_metricas_entrega AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise B√°sica de Entregas**
```sql
SELECT * FROM mv_metricas_entrega;
```

2. **Pedidos Atrasados**
```sql
SELECT *
FROM mv_metricas_entrega
WHERE status_entrega = 'Atrasado'
ORDER BY tempo_real_dias DESC;
```

3. **An√°lise de Satisfa√ß√£o**
```sql
SELECT
    status,
    satisfacao_media,
    CASE
        WHEN satisfacao_media >= 4.5 THEN '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê'
        WHEN satisfacao_media >= 4.0 THEN '‚≠ê‚≠ê‚≠ê‚≠ê'
        WHEN satisfacao_media >= 3.0 THEN '‚≠ê‚≠ê‚≠ê'
        ELSE '‚≠ê‚≠ê'
    END as rating
FROM mv_metricas_entrega
WHERE satisfacao_media IS NOT NULL;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Timeline de Entrega
```
Dias     0    1    2    3    4    5    6    7
Prazo    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§
Real     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚ñ≥              ‚ñ≥         ‚ñ≥
     Pedido        Envio     Prazo  Entrega
```

### 2. Matriz de Satisfa√ß√£o
```
Satisfa√ß√£o
    5 ‚îÇ   ‚àô  ‚àô
    4 ‚îÇ ‚àô  ‚àô‚àô ‚àô
    3 ‚îÇ   ‚àô‚àô ‚àô  ‚àô
    2 ‚îÇ ‚àô  ‚àô
    1 ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        1   2   3   4   Atraso (dias)
```

## üìã Pr√©-requisitos

### Estrutura da Tabela
```sql
CREATE TABLE pedidos (
    id serial PRIMARY KEY,
    status text,
    data_pedido timestamp,
    data_entrega_real timestamp,
    prazo_entrega integer,
    avaliacao_entrega numeric
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o Di√°ria
```sql
REFRESH MATERIALIZED VIEW mv_metricas_entrega;
```

### Monitoramento
```sql
-- Verificar inconsist√™ncias
SELECT *
FROM pedidos
WHERE data_entrega_real < data_pedido
   OR avaliacao_entrega NOT BETWEEN 1 AND 5;
```

## üìä KPIs Sugeridos

1. **Taxa de Entregas no Prazo**
```sql
SELECT
    COUNT(*) FILTER (WHERE tempo_medio_real <= prazo_medio_prometido)::float /
    COUNT(*) * 100 as taxa_no_prazo
FROM mv_metricas_entrega
WHERE status = 'ENTREGUE';
```

2. **Correla√ß√£o Atraso vs Satisfa√ß√£o**
```sql
SELECT
    status,
    CORR(tempo_medio_real - prazo_medio_prometido, satisfacao_media) as correlacao
FROM mv_metricas_entrega
GROUP BY status;
```

## üìà An√°lises Complementares

1. **Atrasos por Per√≠odo**
```sql
SELECT
    DATE_TRUNC('month', data_pedido) as mes,
    AVG(DATE_PART('day', data_entrega_real - data_pedido)) as tempo_medio
FROM pedidos
WHERE status = 'ENTREGUE'
GROUP BY mes
ORDER BY mes;
```

2. **Distribui√ß√£o de Atrasos**
```sql
SELECT
    CASE
        WHEN tempo_medio_real <= prazo_medio_prometido THEN 'No Prazo'
        WHEN tempo_medio_real <= prazo_medio_prometido + 1 THEN 'Atraso 1 dia'
        WHEN tempo_medio_real <= prazo_medio_prometido + 2 THEN 'Atraso 2 dias'
        ELSE 'Atraso 3+ dias'
    END as faixa_atraso,
    COUNT(*) as total_pedidos
FROM mv_metricas_entrega
GROUP BY faixa_atraso;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:35:23 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de entregas
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## ‚≠ê An√°lise de Satisfa√ß√£o por Produto e Categoria
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:38:03-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-An√°lise%20de%20Satisfa√ß√£o-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query desenvolvida para an√°lise profunda da satisfa√ß√£o dos clientes, segmentada por produtos e categorias, identificando padr√µes de avalia√ß√£o e destacando os produtos mais bem avaliados.

## üìä Estrutura de Avalia√ß√£o
```mermaid
graph TD
    A[Categoria] --> B[Produtos]
    B --> C[Avalia√ß√µes]
    C --> D[Positivas ‚â•4]
    C --> E[Negativas ‚â§2]
    C --> F[M√©dia]
```

## üîç Estrutura da Query

### 1. An√°lise Detalhada de Satisfa√ß√£o
```sql
WITH satisfacao_detalhada AS (
    SELECT
        c.nome as categoria,
        p.nome as produto,
        COUNT(DISTINCT ip.pedido_id) as total_avaliacoes,
        ROUND(AVG(ip.avaliacao_produto)::numeric, 2) as media_produto,
        COUNT(CASE WHEN ip.avaliacao_produto >= 4 THEN 1 END) as avaliacoes_positivas,
        COUNT(CASE WHEN ip.avaliacao_produto <= 2 THEN 1 END) as avaliacoes_negativas
    FROM categorias c
    LEFT JOIN produtos p ON c.id = p.categoria_id
    LEFT JOIN itens_pedido ip ON p.id = ip.produto_id
    WHERE ip.avaliacao_produto IS NOT NULL
    GROUP BY c.nome, p.nome
)
```

## üìà M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| media_categoria | M√©dia de avalia√ß√µes | `AVG(media_produto)` |
| total_avaliacoes | Total de avalia√ß√µes | `SUM(total_avaliacoes)` |
| percentual_positivas | % avalia√ß√µes ‚â•4 | `(avaliacoes_positivas / total) * 100` |
| melhores_produtos | Produtos com nota ‚â•4 | Lista agregada com notas |

## üìä Exemplo de Resultado

```
Categoria  ‚îÇ M√©dia ‚îÇ Total ‚îÇ % Positivas ‚îÇ Melhores Produtos
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Tech       ‚îÇ  4.5  ‚îÇ  500  ‚îÇ    85%      ‚îÇ Prod A (4.8), Prod B (4.6)
Casa       ‚îÇ  4.2  ‚îÇ  300  ‚îÇ    78%      ‚îÇ Prod C (4.5), Prod D (4.3)
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_itens_pedido_avaliacao ON itens_pedido(avaliacao_produto);
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_avaliacoes_produto ON itens_pedido(produto_id, avaliacao_produto);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_satisfacao_categoria AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise Geral de Satisfa√ß√£o**
```sql
SELECT * FROM mv_satisfacao_categoria
ORDER BY media_categoria DESC;
```

2. **Categorias com Problemas**
```sql
SELECT *
FROM mv_satisfacao_categoria
WHERE percentual_positivas < 70
ORDER BY percentual_positivas;
```

3. **Top Produtos por Avalia√ß√£o**
```sql
SELECT
    categoria,
    melhores_produtos
FROM mv_satisfacao_categoria
WHERE media_categoria >= 4.5;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Distribui√ß√£o de Avalia√ß√µes
```
Avalia√ß√µes
    5‚òÖ ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  40%
    4‚òÖ ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    30%
    3‚òÖ ‚îÇ‚ñà‚ñà‚ñà‚ñà      20%
    2‚òÖ ‚îÇ‚ñà‚ñà        10%
    1‚òÖ ‚îÇ          0%
```

### 2. Matriz de Satisfa√ß√£o
```
Avalia√ß√£o
    5 ‚îÇ   ‚àô  ‚àô‚àô  ‚àô
    4 ‚îÇ ‚àô  ‚àô‚àô‚àô ‚àô‚àô ‚àô
    3 ‚îÇ   ‚àô‚àô ‚àô  ‚àô
    2 ‚îÇ ‚àô  ‚àô
    1 ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        100  300  500  Total Avalia√ß√µes
```

## üìã Pr√©-requisitos

### Estrutura das Tabelas
```sql
CREATE TABLE categorias (
    id serial PRIMARY KEY,
    nome text
);

CREATE TABLE produtos (
    id serial PRIMARY KEY,
    categoria_id integer,
    nome text
);

CREATE TABLE itens_pedido (
    pedido_id integer,
    produto_id integer,
    avaliacao_produto numeric
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o Di√°ria
```sql
REFRESH MATERIALIZED VIEW mv_satisfacao_categoria;
```

### Monitoramento
```sql
-- Verificar avalia√ß√µes suspeitas
SELECT p.nome, ip.avaliacao_produto, COUNT(*)
FROM produtos p
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY p.nome, ip.avaliacao_produto
HAVING COUNT(*) > 100;
```

## üìä KPIs Sugeridos

1. **Net Promoter Score (NPS)**
```sql
SELECT
    categoria,
    ((COUNT(*) FILTER (WHERE avaliacao_produto >= 4)::float /
      COUNT(*) * 100) -
     (COUNT(*) FILTER (WHERE avaliacao_produto <= 2)::float /
      COUNT(*) * 100)) as nps
FROM produtos p
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY categoria;
```

2. **Tend√™ncia de Satisfa√ß√£o**
```sql
SELECT
    DATE_TRUNC('month', data_avaliacao) as mes,
    categoria,
    AVG(avaliacao_produto) as media_mes
FROM produtos p
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY mes, categoria
ORDER BY mes, categoria;
```

## üìà An√°lises Complementares

1. **Correla√ß√£o Pre√ßo vs Satisfa√ß√£o**
```sql
SELECT
    categoria,
    CORR(p.preco_venda, ip.avaliacao_produto) as correlacao
FROM produtos p
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY categoria;
```

2. **An√°lise de Coment√°rios**
```sql
SELECT
    categoria,
    COUNT(*) FILTER (WHERE comentario IS NOT NULL) as total_comentarios,
    COUNT(*) FILTER (WHERE comentario LIKE '%problema%') as comentarios_negativos
FROM produtos p
JOIN itens_pedido ip ON p.id = ip.produto_id
GROUP BY categoria;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:38:03 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da an√°lise de satisfa√ß√£o
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
## üì¶ An√°lise de Previs√£o de Reposi√ß√£o de Estoque
![Last Update](https://img.shields.io/badge/√öltima%20Atualiza√ß√£o-2025--02--21%2004:40:24-brightgreen)
![Developer](https://img.shields.io/badge/Desenvolvedor-nedio--junior-blue)
![Type](https://img.shields.io/badge/Tipo-Gest√£o%20de%20Estoque-orange)
![Database](https://img.shields.io/badge/Database-PostgreSQL-blue)

## üéØ Objetivo
Query desenvolvida para an√°lise e previs√£o de reposi√ß√£o de estoque, considerando hist√≥rico de consumo, n√≠veis de estoque e lead time de reposi√ß√£o.

## üìä Fluxo de An√°lise
```mermaid
graph LR
    A[Consumo Mensal] --> D[M√©tricas]
    B[Estoque Atual] --> D
    C[Lead Time] --> D
    D --> E[Previs√£o]
    E --> F[Status]
```

## üîç Estrutura da Query

### 1. An√°lise de Consumo Mensal
```sql
WITH consumo_mensal AS (
    SELECT
        produto_id,
        -SUM(CASE
            WHEN tipo_movimento = 'sa√≠da' THEN quantidade
            ELSE 0
        END) as quantidade_vendida,
        COUNT(DISTINCT DATE_TRUNC('month', data_movimento)) as meses_ativos
    FROM movimentacao_estoque
    WHERE tipo_movimento = 'sa√≠da'
    GROUP BY produto_id
)
```

### 2. M√©tricas de Reposi√ß√£o
```sql
metricas_reposicao AS (
    SELECT
        p.id,
        p.nome,
        c.nome as categoria,
        p.estoque_atual,
        p.estoque_minimo,
        p.estoque_maximo,
        p.lead_time_reposicao,
        cm.quantidade_vendida,
        ROUND((cm.quantidade_vendida::numeric /
            NULLIF(cm.meses_ativos, 0)), 2) as media_consumo_mensal
    FROM produtos p
    LEFT JOIN categorias c ON p.categoria_id = c.id
    LEFT JOIN consumo_mensal cm ON p.id = cm.produto_id
)
```

## üìà M√©tricas Calculadas

| M√©trica | Descri√ß√£o | C√°lculo |
|---------|-----------|----------|
| consumo_medio_mensal | M√©dia mensal de vendas | `quantidade_vendida / meses_ativos` |
| dias_estoque_restantes | Dias at√© acabar o estoque | `(estoque_atual / consumo_medio) * 30` |
| status_estoque | Status do n√≠vel de estoque | Baseado no estoque m√≠nimo |
| quantidade_reposicao | Quantidade a repor | `estoque_maximo - estoque_atual` |

## üìä Exemplo de Resultado

```
Produto  ‚îÇ Estoque ‚îÇ M√≠nimo ‚îÇ Consumo ‚îÇ Dias Rest ‚îÇ Status  ‚îÇ Reposi√ß√£o
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Prod A   ‚îÇ   100   ‚îÇ   150  ‚îÇ    50   ‚îÇ    60    ‚îÇ ATEN√á√ÉO ‚îÇ    400
Prod B   ‚îÇ    50   ‚îÇ   100  ‚îÇ    40   ‚îÇ    37    ‚îÇ CR√çTICO ‚îÇ    450
Prod C   ‚îÇ   500   ‚îÇ   200  ‚îÇ    30   ‚îÇ   500    ‚îÇ NORMAL  ‚îÇ      0
```

## ‚ö° Otimiza√ß√£o de Performance

### 1. √çndices Recomendados
```sql
CREATE INDEX idx_movimentacao_tipo ON movimentacao_estoque(tipo_movimento);
CREATE INDEX idx_movimentacao_data ON movimentacao_estoque(data_movimento);
CREATE INDEX idx_produtos_estoque ON produtos(estoque_atual, estoque_minimo);
```

### 2. View Materializada
```sql
CREATE MATERIALIZED VIEW mv_previsao_estoque AS
-- Query completa aqui
WITH (data-checks=true);
```

## üöÄ Como Usar

1. **An√°lise de Produtos Cr√≠ticos**
```sql
SELECT *
FROM mv_previsao_estoque
WHERE status_estoque = 'CR√çTICO'
ORDER BY dias_estoque_restantes;
```

2. **Necessidade de Reposi√ß√£o**
```sql
SELECT
    categoria,
    SUM(quantidade_reposicao) as total_reposicao
FROM mv_previsao_estoque
GROUP BY categoria
HAVING SUM(quantidade_reposicao) > 0;
```

3. **Produtos em Risco**
```sql
SELECT *
FROM mv_previsao_estoque
WHERE dias_estoque_restantes <= lead_time_reposicao
ORDER BY dias_estoque_restantes;
```

## üìä Visualiza√ß√µes Recomendadas

### 1. Status do Estoque
```
NORMAL   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 60%
ATEN√á√ÉO  ‚îÇ‚ñà‚ñà‚ñà‚ñà        20%
CR√çTICO  ‚îÇ‚ñà‚ñà‚ñà‚ñà        20%
```

### 2. Matriz de Risco
```
Consumo
Alto    ‚îÇ üü°  üî¥  üî¥
M√©dio   ‚îÇ üü¢  üü°  üî¥
Baixo   ‚îÇ üü¢  üü¢  üü°
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        Alto M√©dio Baixo  Estoque
```

## üìã Pr√©-requisitos

### Estrutura das Tabelas
```sql
CREATE TABLE produtos (
    id serial PRIMARY KEY,
    nome text,
    categoria_id integer,
    estoque_atual integer,
    estoque_minimo integer,
    estoque_maximo integer,
    lead_time_reposicao integer
);

CREATE TABLE movimentacao_estoque (
    produto_id integer,
    tipo_movimento text,
    quantidade integer,
    data_movimento timestamp
);
```

## üîÑ Manuten√ß√£o

### Atualiza√ß√£o Di√°ria
```sql
REFRESH MATERIALIZED VIEW mv_previsao_estoque;
```

### Monitoramento
```sql
-- Verificar inconsist√™ncias
SELECT *
FROM produtos
WHERE estoque_atual < 0
   OR estoque_minimo > estoque_maximo;
```

## üìä KPIs Sugeridos

1. **Cobertura de Estoque**
```sql
SELECT
    categoria,
    AVG(dias_estoque_restantes) as cobertura_media
FROM mv_previsao_estoque
GROUP BY categoria;
```

2. **Efici√™ncia do Estoque**
```sql
SELECT
    categoria,
    SUM(estoque_atual) as estoque_total,
    SUM(estoque_atual * custo_unitario) as valor_estoque
FROM mv_previsao_estoque
JOIN produtos p ON p.id = produto_id
GROUP BY categoria;
```

## üìà An√°lises Complementares

1. **Sazonalidade**
```sql
SELECT
    DATE_TRUNC('month', data_movimento) as mes,
    produto_id,
    SUM(quantidade) as consumo_mensal
FROM movimentacao_estoque
WHERE tipo_movimento = 'sa√≠da'
GROUP BY mes, produto_id;
```

2. **Lead Time Real vs Planejado**
```sql
SELECT
    produto_id,
    AVG(data_recebimento - data_pedido) as lead_time_real,
    lead_time_reposicao as lead_time_planejado
FROM pedidos_reposicao pr
JOIN produtos p ON p.id = pr.produto_id
GROUP BY produto_id, lead_time_reposicao;
```

## üë§ Metadados
- **Desenvolvedor**: nedio-junior
- **√öltima Atualiza√ß√£o**: 2025-02-21 04:40:24 UTC
- **Vers√£o**: 1.0.0

## üì´ Suporte
- Email: [seu-email@dominio.com]
- GitHub: [@nedio-junior](https://github.com/nedio-junior)

## üìù Changelog

### v1.0.0 (2025-02-21)
- ‚úÖ Implementa√ß√£o inicial da previs√£o de estoque
- ‚úÖ Otimiza√ß√£o de performance
- ‚úÖ Documenta√ß√£o completa

---
¬© 2025 An√°lise de Estoque - Desenvolvido por nedio-junior
---

